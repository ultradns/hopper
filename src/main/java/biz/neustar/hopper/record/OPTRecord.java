// Copyright (c) 1999-2004 Brian Wellington (bwelling@xbill.org)

package biz.neustar.hopper.record;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import biz.neustar.hopper.message.Compression;
import biz.neustar.hopper.message.DClass;
import biz.neustar.hopper.message.DNSInput;
import biz.neustar.hopper.message.DNSOutput;
import biz.neustar.hopper.message.EDNSOption;
import biz.neustar.hopper.message.EDNSOption.Code;
import biz.neustar.hopper.message.ExtendedFlag;
import biz.neustar.hopper.message.Message;
import biz.neustar.hopper.message.Name;
import biz.neustar.hopper.message.Rcode;
import biz.neustar.hopper.message.Type;
import biz.neustar.hopper.resolver.Resolver;
import biz.neustar.hopper.util.Tokenizer;

/**
 * Options - describes Extended DNS (EDNS) properties of a Message. No specific
 * options are defined other than those specified in the header. An OPT should
 * be generated by Resolver.
 * 
 * EDNS is a method to extend the DNS protocol while providing backwards
 * compatibility and not significantly changing the protocol. This
 * implementation of EDNS is mostly complete at level 0.
 * 
 * @see Message
 * @see Resolver
 * 
 * @author Brian Wellington
 */

public class OPTRecord extends Record {

    private static final long serialVersionUID = -6254521894809367938L;

    private List<EDNSOption> options;
    private int payloadSize;

    public OPTRecord() {
    }

    protected Record getObject() {
        return new OPTRecord();
    }

    /**
     * Creates an OPT Record. This is normally called by SimpleResolver, but can
     * also be called by a server.
     * 
     * @param payloadSize
     *            The size of a packet that can be reassembled on the sending
     *            host.
     * @param xrcode
     *            The value of the extended rcode field. This is the upper 16
     *            bits of the full rcode.
     * @param flags
     *            Additional message flags.
     * @param version
     *            The EDNS version that this DNS implementation supports. This
     *            should be 0 for dnsjava.
     * @param options
     *            The list of options that comprise the data field. There are
     *            currently no defined options.
     * @see ExtendedFlag
     */
    public OPTRecord(int payloadSize, int xrcode, int version, int flags,
            List<EDNSOption> options) {

        super(Name.root, Type.OPT, DClass.valueOf(payloadSize),
                ((long) xrcode << 24) + ((long) version << 16) + flags);
        this.payloadSize = payloadSize;
        
        checkU16("payloadSize", payloadSize);
        checkU8("xrcode", xrcode);
        checkU8("version", version);
        checkU16("flags", flags);
        if (options != null) {
            this.options = new ArrayList<EDNSOption>(options);
        }
    }

    /**
     * Creates an OPT Record with no data. This is normally called by
     * SimpleResolver, but can also be called by a server.
     * 
     * @param payloadSize
     *            The size of a packet that can be reassembled on the sending
     *            host.
     * @param xrcode
     *            The value of the extended rcode field. This is the upper 16
     *            bits of the full rcode.
     * @param flags
     *            Additional message flags.
     * @param version
     *            The EDNS version that this DNS implementation supports. This
     *            should be 0 for dnsjava.
     * @see ExtendedFlag
     */
    public OPTRecord(int payloadSize, int xrcode, int version, int flags) {
        this(payloadSize, xrcode, version, flags, null);
    }

    /**
     * Creates an OPT Record with no data. This is normally called by
     * SimpleResolver, but can also be called by a server.
     */
    public OPTRecord(int payloadSize, int xrcode, int version) {
        this(payloadSize, xrcode, version, 0, null);
    }

    protected void rrFromWire(DNSInput in) throws IOException {
        this.payloadSize = this.dclass.getValue();
        if (in.remaining() > 0) {
            options = new ArrayList<EDNSOption>();
        }
        while (in.remaining() > 0) {
            EDNSOption option = EDNSOption.fromWire(in);
            options.add(option);
        }
    }

    protected void rdataFromString(Tokenizer st, Name origin) throws IOException {
        throw st.exception("no text format defined for OPT");
    }

    /** Converts rdata to a String */
    public String rrToString() {
        StringBuffer sb = new StringBuffer();
        if (options != null) {
            sb.append(options);
            sb.append(" ");
        }
        sb.append(" ; payload ");
        sb.append(getPayloadSize());
        sb.append(", xrcode ");
        sb.append(getExtendedRcode());
        sb.append(", version ");
        sb.append(getVersion());
        sb.append(", flags ");
        sb.append(getFlags());
        return sb.toString();
    }

    /** Returns the maximum allowed payload size. */
    public int getPayloadSize() {
        return payloadSize;
    }

    /**
     * Returns the extended Rcode
     * 
     * @see Rcode
     */
    public int getExtendedRcode() {
        return (int) (getTTL() >>> 24);
    }

    /** Returns the highest supported EDNS version */
    public int getVersion() {
        return (int) ((getTTL() >>> 16) & 0xFF);
    }

    /** Returns the EDNS flags */
    public int getFlags() {
        return (int) (getTTL() & 0xFFFF);
    }

    // So hacky, but rfc 2671 requires the class be reused as payload size..    
    protected void toWireCanonical(DNSOutput out, boolean noTTL) {
        toWireCanonical(out, getName(), getType(), payloadSize, noTTL ? 0 : getTTL());
    }
    
    // same as above..
    public void toWire(DNSOutput out, int section, Compression c) {
        toWire(out, section, c, getName(), getType(), payloadSize, getTTL());
    }
    
    public void rrToWire(DNSOutput out, Compression c, boolean canonical) {
        if (options == null) {
            return;
        }
        Iterator<EDNSOption> it = options.iterator();
        while (it.hasNext()) {
            EDNSOption option = it.next();
            option.toWire(out);
        }
    }

    /**
     * Gets all options in the OPTRecord. This returns a list of EDNSOptions.
     */
    public List<EDNSOption> getOptions() {
        if (options == null) {
            return Collections.emptyList();
        }
        return Collections.unmodifiableList(options);
    }

    /**
     * Gets all options in the OPTRecord with a specific code. This returns a
     * list of EDNSOptions.
     */
    public List<EDNSOption> getOptions(int code) {
        if (options == null) {
            return Collections.emptyList();
        }
        List<EDNSOption> list = new ArrayList<EDNSOption>();
        for (Iterator<EDNSOption> it = options.iterator(); it.hasNext();) {
            EDNSOption opt = it.next();
            //if (opt.getCode() == code) {
            if (opt.getCode().equals(Code.valueOf(code))) {
                list.add(opt);
            }
        }
        return list;
    }

}
